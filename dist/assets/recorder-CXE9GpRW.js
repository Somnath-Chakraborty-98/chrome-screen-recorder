async function k(d={}){const{onChunk:g,onError:l}=d,o=await navigator.mediaDevices.getDisplayMedia({video:!0,audio:!0});let a=null;try{a=await navigator.mediaDevices.getUserMedia({audio:!0})}catch(e){console.warn("Mic access not granted or unavailable",e)}const s=new AudioContext,n=s.createMediaStreamDestination();if(o.getAudioTracks().length>0){const e=new MediaStream(o.getAudioTracks());s.createMediaStreamSource(e).connect(n)}a&&a.getAudioTracks().length>0&&s.createMediaStreamSource(new MediaStream(a.getAudioTracks())).connect(n);const r=new MediaStream;o.getVideoTracks().forEach(e=>r.addTrack(e)),n.stream.getAudioTracks().forEach(e=>r.addTrack(e));const u=d.mimeType||"video/webm; codecs=vp9,opus";let t;try{t=new MediaRecorder(r,{mimeType:u})}catch{t=new MediaRecorder(r)}const m=[];return t.ondataavailable=e=>{e.data&&e.data.size&&(m.push(e.data),g?.(e.data))},t.onerror=e=>l?.(new Error(String(e))),t.start(1e3),{stop:async()=>new Promise((e,p)=>{t.onstop=()=>{try{r.getTracks().forEach(c=>c.stop()),o.getTracks().forEach(c=>c.stop()),a?.getTracks().forEach(c=>c.stop()),s.close().catch(()=>{});const i=new Blob(m,{type:t.mimeType||u});e(i)}catch(i){p(i)}},t.stop()}),pause:()=>{t.state==="recording"&&t.pause()},resume:()=>{t.state==="paused"&&t.resume()}}}export{k as startRecorder};
